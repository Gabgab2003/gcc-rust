#![allow(dead_code)]

use std::{
    os::raw::{c_char, c_uint, c_ulong},
    ptr::null_mut,
};

#[repr(transparent)]
pub struct Location(c_uint);

pub const UNKNOWN_LOCATION: Location = Location(0);
pub const BUILTINS_LOCATION: Location = Location(1);

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum IntegerTypeKind {
    Char,
    SignedChar,
    UnsignedChar,
    Short,
    UnsignedShort,
    Int,
    UnsignedInt,
    Long,
    UnsignedLong,
    LongLong,
    UnsignedLongLong,

    IntN0,
    UnsignedIntN0,
    IntN1,
    UnsignedIntN1,
    IntN2,
    UnsignedIntN2,
    IntN3,
    UnsignedIntN3,

    None,
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TreeIndex {
    ErrorMark,
    IntqiType,
    InthiType,
    IntsiType,
    IntdiType,
    InttiType,
    UintqiType,
    UinthiType,
    UintsiType,
    UintdiType,
    UinttiType,
    AtomicqiType,
    AtomichiType,
    AtomicsiType,
    AtomicdiType,
    AtomictiType,
    Uint6Type,
    Uint2Type,
    Uint4Type,
    Void,
    IntegerZero,
    IntegerOne,
    IntegerThree,
    IntegerMinusOne,
    NullPointer,
    SizeZero,
    SizeOne,
    BitsizeZero,
    BitsizeOne,
    BitsizeUnit,
    Public,
    Protected,
    Private,
    BooleanFalse,
    BooleanTrue,
    FloatType,
    DoubleType,
    LongDoubleType,
    Float6Type,
    Float2Type,
    Float4Type,
    Float28Type,
    Float2XType,
    Float4XType,
    Float28XType,
    ComplexIntegerType,
    ComplexFloatType,
    ComplexDoubleType,
    ComplexLongDoubleType,
    ComplexFloat6Type,
    ComplexFloat2Type,
    ComplexFloat4Type,
    ComplexFloat28Type,
    ComplexFloat2XType,
    ComplexFloat4XType,
    ComplexFloat28XType,
    FloatPtrType,
    DoublePtrType,
    LongDoublePtrType,
    IntegerPtrType,
    VoidType,
    PtrType,
    ConstPtrType,
    SizeType,
    PidType,
    PtrdiffType,
    VaListType,
    VaListGprCounterField,
    VaListFprCounterField,
    BooleanType,
    FileptrType,
    ConstTmPtrType,
    FenvT_PtrType,
    ConstFenvT_PtrType,
    FexceptT_PtrType,
    ConstFexceptT_PtrType,
    PointerSizedType,
    Dfloat2Type,
    Dfloat4Type,
    Dfloat28Type,
    VoidListNode,
    MainIdentifier,
    SatSfractType,
    SatFractType,
    SatLfractType,
    SatLlfractType,
    SatUsfractType,
    SatUfractType,
    SatUlfractType,
    SatUllfractType,
    SfractType,
    FractType,
    LfractType,
    LlfractType,
    UsfractType,
    UfractType,
    UlfractType,
    UllfractType,
    SatSaccumType,
    SatAccumType,
    SatLaccumType,
    SatLlaccumType,
    SatUsaccumType,
    SatUaccumType,
    SatUlaccumType,
    SatUllaccumType,
    SaccumType,
    AccumType,
    LaccumType,
    LlaccumType,
    UsaccumType,
    UaccumType,
    UlaccumType,
    UllaccumType,
    QqType,
    HqType,
    SqType,
    DqType,
    TqType,
    UqqType,
    UhqType,
    UsqType,
    UdqType,
    UtqType,
    SatQqType,
    SatHqType,
    SatSqType,
    SatDqType,
    SatTqType,
    SatUqqType,
    SatUhqType,
    SatUsqType,
    SatUdqType,
    SatUtqType,
    HaType,
    SaType,
    DaType,
    TaType,
    UhaType,
    UsaType,
    UdaType,
    UtaType,
    SatHaType,
    SatSaType,
    SatDaType,
    SatTaType,
    SatUhaType,
    SatUsaType,
    SatUdaType,
    SatUtaType,
    OptimizationDefault,
    OptimizationCurrent,
    TargetOptionDefault,
    TargetOptionCurrent,
    CurrentTargetPragma,
    CurrentOptimizePragma,
    ChrecDontKnow,
    ChrecKnown,

    Max,
}

// TODO: autogenerate this
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TreeCode {
    ErrorMark,
    IdentifierNode,
    TreeList,
    TreeVec,
    Block,
    OffsetType,
    EnumeralType,
    BooleanType,
    IntegerType,
    RealType,
    PointerType,
    ReferenceType,
    NullptrType,
    FixedPointType,
    ComplexType,
    VectorType,
    ArrayType,
    RecordType,
    UnionType,
    QualUnionType,
    VoidType,
    FunctionType,
    MethodType,
    LangType,
    VoidCst,
    IntegerCst,
    PolyIntCst,
    RealCst,
    FixedCst,
    ComplexCst,
    VectorCst,
    StringCst,
    FunctionDecl,
    LabelDecl,
    FieldDecl,
    VarDecl,
    ConstDecl,
    ParmDecl,
    TypeDecl,
    ResultDecl,
    DebugExprDecl,
    DebugBeginStmt,
    NamespaceDecl,
    ImportedDecl,
    NamelistDecl,
    TranslationUnitDecl,
    ComponentRef,
    BitFieldRef,
    ArrayRef,
    ArrayRangeRef,
    RealpartExpr,
    ImagpartExpr,
    ViewConvertExpr,
    IndirectRef,
    ObjTypeRef,
    Constructor,
    CompoundExpr,
    ModifyExpr,
    InitExpr,
    TargetExpr,
    CondExpr,
    VecDuplicateExpr,
    VecSeriesExpr,
    VecCondExpr,
    VecPermExpr,
    BindExpr,
    CallExpr,
    WithCleanupExpr,
    CleanupPointExpr,
    PlaceholderExpr,
    PlusExpr,
    MinusExpr,
    MultExpr,
    PointerPlusExpr,
    PointerDiffExpr,
    MultHighpartExpr,
    TruncDivExpr,
    CeilDivExpr,
    FloorDivExpr,
    RoundDivExpr,
    TruncModExpr,
    CeilModExpr,
    FloorModExpr,
    RoundModExpr,
    RdivExpr,
    ExactDivExpr,
    FixTruncExpr,
    FloatExpr,
    NegateExpr,
    MinExpr,
    MaxExpr,
    AbsExpr,
    AbsuExpr,
    LshiftExpr,
    RshiftExpr,
    LrotateExpr,
    RrotateExpr,
    BitIorExpr,
    BitXorExpr,
    BitAndExpr,
    BitNotExpr,
    TruthAndifExpr,
    TruthOrifExpr,
    TruthAndExpr,
    TruthOrExpr,
    TruthXorExpr,
    TruthNotExpr,
    LtExpr,
    LeExpr,
    GtExpr,
    GeExpr,
    LtgtExpr,
    EqExpr,
    NeExpr,
    UnorderedExpr,
    OrderedExpr,
    UnltExpr,
    UnleExpr,
    UngtExpr,
    UngeExpr,
    UneqExpr,
    RangeExpr,
    ParenExpr,
    ConvertExpr,
    AddrSpaceConvertExpr,
    FixedConvertExpr,
    NopExpr,
    NonLvalueExpr,
    CompoundLiteralExpr,
    SaveExpr,
    AddrExpr,
    FdescExpr,
    BitInsertExpr,
    ComplexExpr,
    ConjExpr,
    PredecrementExpr,
    PreincrementExpr,
    PostdecrementExpr,
    PostincrementExpr,
    VaArgExpr,
    TryCatchExpr,
    TryFinallyExpr,
    EhElseExpr,
    DeclExpr,
    LabelExpr,
    GotoExpr,
    ReturnExpr,
    ExitExpr,
    LoopExpr,
    SwitchExpr,
    CaseLabelExpr,
    AsmExpr,
    SsaName,
    CatchExpr,
    EhFilterExpr,
    ScevKnown,
    ScevNotKnown,
    PolynomialChrec,
    StatementList,
    AssertExpr,
    TreeBinfo,
    WithSizeExpr,
    RealignLoadExpr,
    TargetMemRef,
    MemRef,
    OaccParallel,
    OaccKernels,
    OaccSerial,
    OaccData,
    OaccHostData,
    OmpParallel,
    OmpTask,
    OmpFor,
    OmpSimd,
    OmpDistribute,
    OmpTaskloop,
    OmpLoop,
    OaccLoop,
    OmpTeams,
    OmpTargetData,
    OmpTarget,
    OmpSections,
    OmpOrdered,
    OmpCritical,
    OmpSingle,
    OmpTaskgroup,
    OmpScan,
    OmpSection,
    OmpMaster,
    OaccCache,
    OaccDeclare,
    OaccEnterData,
    OaccExitData,
    OaccUpdate,
    OmpTargetUpdate,
    OmpTargetEnterData,
    OmpTargetExitData,
    OmpAtomic,
    OmpAtomicRead,
    OmpAtomicCaptureOld,
    OmpAtomicCaptureNew,
    OmpClause,
    TransactionExpr,
    DotProdExpr,
    WidenSumExpr,
    SadExpr,
    WidenMultExpr,
    WidenMultPlusExpr,
    WidenMultMinusExpr,
    WidenLshiftExpr,
    VecWidenMultHiExpr,
    VecWidenMultLoExpr,
    VecWidenMultEvenExpr,
    VecWidenMultOddExpr,
    VecUnpackHiExpr,
    VecUnpackLoExpr,
    VecUnpackFloatHiExpr,
    VecUnpackFloatLoExpr,
    VecUnpackFixTruncHiExpr,
    VecUnpackFixTruncLoExpr,
    VecPackTruncExpr,
    VecPackSatExpr,
    VecPackFixTruncExpr,
    VecPackFloatExpr,
    VecWidenLshiftHiExpr,
    VecWidenLshiftLoExpr,
    PredictExpr,
    OptimizationNode,
    TargetOptionNode,
    AnnotateExpr,
}

#[repr(C)]
pub struct TreeNode {
    _private: [u8; 0],
}

#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct Tree(*mut TreeNode);

pub const NULL_TREE: Tree = Tree(null_mut());

impl From<TreeIndex> for Tree {
    fn from(index: TreeIndex) -> Self {
        assert_ne!(index, TreeIndex::Max);

        Tree(unsafe { global_trees[index as usize].0 })
    }
}

impl From<IntegerTypeKind> for Tree {
    fn from(itk: IntegerTypeKind) -> Self {
        assert_ne!(itk, IntegerTypeKind::None);

        Tree(unsafe { integer_types[itk as usize].0 })
    }
}

extern "C" {
    static global_trees: [Tree; TreeIndex::Max as usize];
    static integer_types: [Tree; IntegerTypeKind::None as usize];

    fn _alloc_stmt_list() -> Tree;
    fn _append_to_statement_list(stmt: Tree, list: *mut Tree);
    pub fn _build0(code: TreeCode, tt: Tree) -> Tree;
    pub fn _build1(code: TreeCode, tt: Tree, arg0: Tree) -> Tree;
    pub fn _build2(code: TreeCode, tt: Tree, arg0: Tree, arg1: Tree) -> Tree;
    pub fn _build3(code: TreeCode, tt: Tree, arg0: Tree, arg1: Tree, arg2: Tree) -> Tree;
    pub fn _build4(
        code: TreeCode,
        tt: Tree,
        arg0: Tree,
        arg1: Tree,
        arg2: Tree,
        arg3: Tree,
    ) -> Tree;
    pub fn _build5(
        code: TreeCode,
        tt: Tree,
        arg0: Tree,
        arg1: Tree,
        arg2: Tree,
        arg3: Tree,
        arg4: Tree,
    ) -> Tree;
    pub fn _build_decl(loc: Location, code: TreeCode, name: Tree, tt: Tree) -> Tree;
    pub fn _build_string_literal(
        len: usize,
        string: *const c_char,
        eltype: Tree,
        size: c_ulong,
    ) -> Tree;
    pub fn _build_block(vars: Tree, subblocks: Tree, supercontext: Tree, chain: Tree) -> Tree;
    pub fn _build_call_array_loc(
        loc: Location,
        returntype: Tree,
        fn_ptr: Tree,
        num_args: usize,
        args: *mut Tree,
    ) -> Tree;
    pub fn _build_pointer_type(totype: Tree) -> Tree;
    pub fn _build_function_type_array(
        returntype: Tree,
        num_args: usize,
        argtypes: *mut Tree,
    ) -> Tree;
    pub fn _build_fn_decl(name: *const c_char, decltype: Tree) -> Tree;
    pub fn _create_artifical_label(loc: Location) -> Tree;
    pub fn _gimplify_function_tree(tree: Tree);

    pub fn build_int_constant(inttype: Tree, value: i64) -> Tree;
    pub fn set_fn_result(fn_decl: Tree, result: Tree);
    pub fn set_fn_initial(fn_decl: Tree, tree: Tree);
    pub fn set_fn_saved_tree(fn_decl: Tree, tree: Tree);
    pub fn set_fn_external(fn_decl: Tree, value: bool);
    pub fn set_fn_preserve_p(fn_decl: Tree, value: bool);
    pub fn finalize_decl(tree: Tree);
    pub fn finalize_function(tree: Tree, no_collect: bool);
}

pub struct StatementList(pub Tree);

impl StatementList {
    pub fn new() -> Self {
        Self(unsafe { _alloc_stmt_list() })
    }

    pub fn push(&mut self, stmt: Tree) {
        unsafe {
            _append_to_statement_list(stmt, &mut self.0);
        }
    }
}
